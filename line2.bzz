include "include/vec2.bzz"
include "include/string.bzz"
#################################################
### UTILITY FUNCTIONS ###########################
#################################################

# Write a table as if it was a matrix
function write_knowledge(k, row, col, val) {
    var key = string.concat(string.tostring(row),"-",string.tostring(col))
    k[key] = val
}

# Read a table as if it was a matrix
function read_knowledge(k, row, col) {
    var key = string.concat(string.tostring(row),"-",string.tostring(col))
    if (k[key] == nil) {
        # log("Warning: reading 'nil' value from the knowledge table, returning -1")
        return -1
    } else {
        return k[key]
    }
}

# Int to String 
function itos(i) {
    
    log("Use 'string.tostring(OJB)' instead")
    
    if (i==0) { return "0" }
    if (i==1) { return "1" }
    if (i==2) { return "2" }
    if (i==3) { return "3" }
    if (i==4) { return "4" }
    if (i==5) { return "5" }
    if (i==6) { return "6" }
    if (i==7) { return "7" }
    if (i==8) { return "8" }
    if (i==9) { return "9" }
    
    log("Function 'itos' out of bounds, returning the answer (42)")
    return "42"
}

# String to Int
function stoi(s) {
   if (s=='0') { return 0 }
   if (s=='1') { return 1 }
   if (s=='2') { return 2 }
   if (s=='3') { return 3 }
   if (s=='4') { return 4 }
   if (s=='5') { return 5 }
   if (s=='6') { return 6 }
   if (s=='7') { return 7 }
   if (s=='8') { return 8 }
   if (s=='9') { return 9 }
   
   log("Function 'stoi' out of bounds, returning the answer (42)")
   return 42
   
}

#################################################
### MOVEMENT/COMMUNICATION PRIMITIVES ###########
#################################################

# Lennard-Jones parameters
TARGET     = 250.0 # The equilibrium distance, in cm
EPSILON    = 150.0
# Lennard-Jones interaction magnitude
function lj_magnitude(dist, target, epsilon) {
  return -(epsilon / dist) * ((target / dist)^4 - (target / dist)^2)
}
# Neighbor data to LJ interaction vector
function lj_vector(rid, data) {
  return math.vec2.newp(lj_magnitude(data.distance, TARGET, EPSILON), data.azimuth)
}
# Accumulator of neighbor LJ interactions
function lj_sum(rid, data, accum) {
  return math.vec2.add(data, accum)
}

# Calculates and actuates the flocking interaction
function hexagon() {
  # Calculate accumulator
  ##debug("hex")
  var accum = neighbors.map(lj_vector).reduce(lj_sum, math.vec2.new(0.0, 0.0))
  if(neighbors.count() > 0)
    math.vec2.scale(accum, 1.0 / neighbors.count())
  # Move according to vector
  #goto(accum.x, accum.y)
}

function inform_your_neighborhood() {    
    # Reset to 0 the visibility of all neighbors
    foreach(knowledge, function(key, value) {
          column = string.sub(key, string.length(key)-1,string.length(key))
          if (column=='3') { 
              knowledge[key] = 0 
          }     
    })    
    neighbors.foreach( function(rid, data) {               
        # For each neighbor, send a message with its azimuth, as seen by the broadcasting robot
        message_id = string.tostring(rid)
        neighbors.broadcast(message_id, rtod(data.azimuth))        
        # Record the neighbor azimuth in my own knowledge table
        write_knowledge(knowledge, rid, 0, rtod(data.azimuth))        
        # Record the neighbor distance in my own knowledge table
        write_knowledge(knowledge, rid, 2, data.distance)        
        # Set neighbor as visible
        write_knowledge(knowledge, rid, 3, 1)     
    })    
    # Send a message with the desired direction, as seen by the broadcasting robot
    neighbors.broadcast("direction", local_dir)
    
}

function listen_to_your_neighborhood() {    
    # For all "senders" in my neighborhood, record my azimuth, as seen by them
    message_id = string.tostring(id)
    neighbors.listen(message_id, function(vid, value, rid) {
        write_knowledge(knowledge, rid, 1, value)
    })
}

# Rads to degrees
function rtod(r) {
   return (r*(180.0/math.pi))
}

# Degrees to rads
function dtor(d) {
   return (math.pi*(d/180.0))
}

# Force angles in the (-180,180) interval
function degrees_interval(a) {
    var temp = a
    while ((temp>360.0) or (temp<0.0)) {
        if (temp > 360.0) {
            temp = temp - 360.0
        } else if (temp < 0.0){
            temp = temp + 360.0
        }
    }
    if (temp > 180.0) {
        temp = temp - 360.0
    }
    return temp
}

# Force angles in the (-pi,pi) interval
function radians_interval(a) {
    var temp = a
    while ((temp>2.0*math.pi) or (temp<0.0)) {
        if (temp > 2.0*math.pi) {
            temp = temp - 2.0*math.pi
        } else if (temp < 0.0){
            temp = temp + 2.0*math.pi
        }
    }
    if (temp > math.pi) {
        temp = temp - 2.0*math.pi
    }
    return temp
}

########################################
#
# BARRIER-RELATED FUNCTIONS
#
########################################

function rotating_line() {
    
    #log(id, " in rotating_line")
        
    temp_dist = 0
    desired_azimuth = 0
    neighbors.foreach(
      function(rid, data) {
        #log("robot ", rid, ": azimuth   = ", data.azimuth) 
        #if (neighbors.get(rid).distance < temp_dist) {
        if ((read_knowledge(knowledge, rid, 9)<mydist) and (read_knowledge(knowledge, rid, 9) >= temp_dist)) {
            #temp_dist = neighbors.get(rid).distance
            temp_dist = read_knowledge(knowledge, rid, 9)
            desired_id = rid
            desired_azimuth = neighbors.get(rid).azimuth
        }
    })
    
    log(id, " ", rtod(desired_azimuth), " from robot ", desired_id, " mydist being ", mydist)
    
    speed_factor = 0.5*(mydist/100)
    correction = 0.0
    #if (id == 3) {
        if (math.abs(rtod(desired_azimuth))>95) {
            goto(0.0,-10.0)
        } else if (math.abs(rtod(desired_azimuth))<85) {
            goto(0.0,10.0)  
        } else {
            goto(-speed_factor*(1.0-correction)*math.sin(desired_azimuth),speed_factor*(1.0+correction)*math.cos(desired_azimuth))
        }        
}


BARRIER_VSTIG = 101
ROBOTS = 4

NUM_ROBOTS = 5

function barrier_set(threshold, transf) {
  # #debug("barrier set")
  
  barrier = stigmergy.create(BARRIER_VSTIG)
  statef = function() {
    barrier_wait(threshold, transf)
}

function barrier_ready() {

  barrier.put(id, 1)
}

#
# Executes the barrier
#
function barrier_wait(threshold, transf) {
  #debug("barrier wait: ", barrier.size())
  
  if (vs.get("z") == 4) {
      #log(id, " ready to rotate in barrier_wait")
      rotating_line()
  } else {
  
  inform_your_neighborhood()
  barrier.get(id)
  
  if(barrier.size() >= threshold) {

    barrier = nil
    t = string.split(vs.get("d"),",")
    transf()
  }
  
  }
  
}

function rotate() {
	
	statef = transition_hex
}

function pivot() {
	foreach(t, function(key, value){
			if(t[key] == id) {
				previous = stoi(t[key-1])
				interval = degrees_interval(read_knowledge(knowledge, previous, 0) - 80)
				if (interval<4 and interval>(-4)) {
					#goto(0.0,0.0)
					#debug("pivot")
				}
				else {
					# Figure out how to get the speed up 
					speed = 100
					# x_mov = math.cos(60)
				 	# y_mov = math.sin(60)
                    if (vs.get("z") < 4) {
				 	    goto(speed*x_mov,speed*y_mov)
                    }

				}
			}
		})
}

function transition_hex() {
	#log("trans hex",id)
    
    if (vs.get("z") == 4) {
        #log(id, " ready to rotate in transition hex")
        rotating_line()
    }
    
	inform_your_neighborhood()
	foreach(t, function(key, value){
			if(t[key] == id) {
				previous = stoi(t[key-1])
				interval = degrees_interval(read_knowledge(knowledge, previous, 0) - 180)
				#debug(read_knowledge(knowledge, previous, 0))
				if (interval<5 and interval>(-5)) {
					#goto(0.0,0.0)
					# neighbors.broadcast("dist_to_source", mydist)
					#debug("aligned:")
					# 
					# barrier_set(ROBOTS, hi)
     #  	  			barrier_ready()
				}
				else {
		
					x_mov = math.cos(60)
				 	y_mov = math.sin(60)
                    if (vs.get("z") < 4) {
				 	    goto(x_mov,y_mov)
                    }
				}
			}
		})
}

function alignNearestBot(bot, angle) {
    #log("align nearest bot :",id)
    
	arm_offset = degrees_interval(read_knowledge(knowledge, bot, 1) - angle)
      
      if (arm_offset<1 and arm_offset>(-1)) {
      	  next_angle = degrees_interval(read_knowledge(knowledge, bot, 0) + 180)
      	  if (vs.get("z") < 4) {
              goto(0.0,0.0)
          }
      	  vs.put("a", id)
      	  vs.put("b", next_angle)
          
          vs.put("z", vs.get("z")+1)

      	  posit = vs.get("d")
      	  posit = string.concat(posit,",")
      	  posit = string.concat(posit,string.tostring(id))
      	  vs.put("d", posit)       

      	  write_knowledge(knowledge, id, 4, 1)
      	  barrier_set(ROBOTS, rotate)
      	  barrier_ready()
	  
      } else {      	 
          # local_rotation = degrees_interval( read_knowledge(knowledge, 0, 1) + (180.0 - read_knowledge(knowledge, 0, 0)) )
          # local_arm = degrees_interval(angle - local_rotation)

          if (read_knowledge(knowledge, bot, 2) > 150.0) { 
              x_mov = math.cos(dtor(read_knowledge(knowledge, bot, 0)))
              y_mov = math.sin(dtor(read_knowledge(knowledge, bot, 0)))       
          } else if (read_knowledge(knowledge, bot, 2) < 30.0) {
              x_mov = -math.cos(dtor(read_knowledge(knowledge, bot, 0)))
              y_mov = -math.sin(dtor(read_knowledge(knowledge, bot, 0)))              
          } else {
              spiraling = 2.0+(id/10.0) # Fun stuff but be careful with this, it affects how a robots turns around a central node, use random number generation, eventually
              if (arm_offset > 0) { # Clockwise

                  x_mov = -math.sin(dtor(read_knowledge(knowledge, bot, 0)))
                  y_mov = math.cos(dtor(read_knowledge(knowledge, bot, 0))) * spiraling
              } else { # Counterclockwise
                  x_mov = math.sin(dtor(read_knowledge(knowledge, bot, 0)))
                  y_mov = -math.cos(dtor(read_knowledge(knowledge, bot, 0))) * spiraling
              }
          }
          speed = 100
          if (vs.get("z") < 4) {
              goto(speed * x_mov,speed * y_mov)
          }
      }
  }


function tableMin(t) {
		mini = 999
		robot = 0
	foreach(t, function(key, value){
			if(t[key] < mini) {
				mini = value
				robot = key
			}
		})
	return robot
}

function testing() {
		inform_your_neighborhood()
        if (vs.get("z") < 4) {
		    goto(6.0,20.0)
        }

}


#################################################
### ACTUAL CONTROLLERS ##########################
#################################################

function zero() {   
  # Do not move
  goto(0.0,0.0) 
  inform_your_neighborhood()       
}


function onetwo() {
  # Broadcast information
  inform_your_neighborhood()

      if (read_knowledge(knowledge,id,4) != 1)  {
  	      alignNearestBot(vs.get("a"), vs.get("b")) 
      }   
      
}


function dists() {
	if(id == 0) {
    	# Source robot
   		mydist = 0.
  	}
  	else {
    	# Other robots
	    mydist = 1000
	    # Listen to other robots' distances
	    neighbors.listen("dist_to_source",
	      function(value_id, value, robot_id) {
            write_knowledge(knowledge, robot_id, 9, value) 
	        mydist = math.min( mydist, neighbors.get(robot_id).distance + value)
            if (robot_id==0) {
                mydist = neighbors.get(robot_id).distance
            }
	      })
  	}
}

#################################################
### BUZZ FUNCTIONS ##############################
#################################################

# Executed at init time
function init() { 
  s0 = swarm.create(0)
  s1 = swarm.create(1)
  s0.select( id == 0 )
  s1 = s0.others(133)

  # Local knowledge table
  knowledge = {}
  t ={}
  # Virtual Stigmergy
  vs = stigmergy.create(2)
  # barrier = stigmergy.create(BARRIER_VSTIG)
  
  iden = 0
  vs_value = 0
  angle = 90
  posit = "0"
  
  vs.put("a", vs_value) # ID for the next bot to follow
  vs.put("b", angle)   # Angle for the next bot to follow
  # vs.put("c", vs_value)  
  vs.put("d", posit) # Vstig for the position of the robot
  # vs.put("e", iden) #
  num_aligned = 0
  vs.put("z", num_aligned)
  
  # Update local knowledge with information from the neighbors
  listen_to_your_neighborhood()
  
  iteration_counter = 0
  dists()

  # Variables initialization
  statef = onetwo
  
}

# Executed every time step
function step() {
    
  neighbors.broadcast("dist_to_source", mydist)
  iteration_counter = iteration_counter+1
  if (iteration_counter%20 == 0) {
      dists()
  }
  
  if(vs.get("z")<4) {
  log(id, " ", mydist)
  }
  
  s0.exec(zero)
  # o.exec(onetwo)
  s1.exec(statef)
  
  
  # #debug(mydist)
}

# Executed once when the robot (or the simulator) is reset.
function reset() {
}
# Execute at exit
function destroy() {
}
